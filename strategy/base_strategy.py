# strategy/base_strategy.py
# –ê–Ω–∞–ª–∏—Ç–∏–∫–∞: —Å–≤–µ—á–∏, –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã, —É—Ä–æ–≤–Ω–∏, TP/SL –æ—Ç —É—Ä–æ–≤–Ω–µ–π; —Ñ–æ—Ä–º–∞—Ç ¬´üíé –°–ò–ì–ù–ê–õ¬ª

import math
import asyncio
from typing import Dict, Any, List, Tuple, Optional

import pandas as pd
import numpy as np
from ta.trend import EMAIndicator, MACD, ADXIndicator
from ta.momentum import RSIIndicator

from config import (
    RSI_PERIOD, ADX_PERIOD, BB_PERIOD,
    EMA_FAST, EMA_SLOW,
)
# get_candles –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å (df) –∏–ª–∏ (df, exchange). –ü–æ–¥–¥–µ—Ä–∂–∏–º –æ–±–∞.
from services.market_data import get_candles


# ------------- –£–¢–ò–õ–´ -------------
def _safe_get_candles(symbol: str, tf: str, limit: int = 300) -> Tuple[pd.DataFrame, Optional[str]]:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ get_candles: –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ (df), —Ç–∞–∫ –∏ (df, exchange).
    –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ df: –∫–æ–ª–æ–Ω–∫–∏ ['time','open','high','low','close','volume'] –∏ datetime –≤ 'time'.
    """
    res = asyncio.get_event_loop().run_until_complete(get_candles(symbol, tf, limit=limit)) \
        if asyncio.get_event_loop().is_running() is False else None
    # –ï—Å–ª–∏ —É–∂–µ –≤–Ω—É—Ç—Ä–∏ async (PTB) ‚Äî –ø—Ä–æ—Å—Ç–æ –≤—ã–∑—ã–≤–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é
    if res is None:
        res = get_candles(symbol, tf, limit=limit)
    if asyncio.iscoroutine(res):
        # –µ—Å–ª–∏ –∫—Ç–æ-—Ç–æ –ø–æ–º–µ—Ç–∏–ª async ‚Äî –¥–æ–∂–º—ë–º
        df_res = asyncio.get_event_loop().run_until_complete(res)
    else:
        df_res = res

    exchange = None
    if isinstance(df_res, tuple) and len(df_res) >= 1:
        df = df_res[0]
        if len(df_res) >= 2:
            exchange = df_res[1]
    else:
        df = df_res

    if df is None or len(df) == 0:
        raise ValueError(f"No candles for {symbol} {tf}")

    # –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ –Ω—É–∂–Ω—ã–º –∫–æ–ª–æ–Ω–∫–∞–º
    cols = [c.lower() for c in df.columns]
    df.columns = cols
    needed = {"time", "open", "high", "low", "close"}
    if not needed.issubset(set(cols)):
        raise ValueError(f"Candles missing columns: need {needed}, got {set(cols)}")

    # –≤—Ä–µ–º—è –≤ datetime
    if not np.issubdtype(df["time"].dtype, np.datetime64):
        df["time"] = pd.to_datetime(df["time"], utc=True, errors="coerce")

    df = df.sort_values("time").reset_index(drop=True)
    return df, exchange


def _ema(series: pd.Series, period: int) -> pd.Series:
    return EMAIndicator(series, window=period).ema_indicator()


def _bb_width(close: pd.Series, period: int = 20, std: float = 2.0) -> pd.Series:
    ma = close.rolling(period).mean()
    sd = close.rolling(period).std(ddof=0)
    upper = ma + std * sd
    lower = ma - std * sd
    width = (upper - lower) / ma.replace(0, np.nan) * 100.0
    return width


def _calc_levels(df: pd.DataFrame, lookback: int = 120) -> Dict[str, List[float]]:
    """
    –ü—Ä–æ—Å—Ç–µ–π—à–∏–µ —É—Ä–æ–≤–Ω–∏: —ç–∫—Å—Ç—Ä–µ–º—É–º—ã —Å–≤–∏–Ω–≥–æ–≤ –∑–∞ lookback.
    –ë–µ—Ä—ë–º 2 –±–ª–∏–∂–∞–π—à–∏—Ö —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è —Å–≤–µ—Ä—Ö—É –∏ 2 –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Å–Ω–∏–∑—É –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ü–µ–Ω—ã.
    """
    sub = df.tail(lookback).copy()
    price = float(sub["close"].iloc[-1])

    # –ª–æ–∫–∞–ª—å–Ω—ã–µ —ç–∫—Å—Ç—Ä–µ–º—É–º—ã
    highs = sub["high"].rolling(5, center=True).max()
    lows = sub["low"].rolling(5, center=True).min()

    # –∫–∞–Ω–¥–∏–¥–∞—Ç—ã
    r_candidates = sorted(highs.dropna().unique().tolist())
    s_candidates = sorted(lows.dropna().unique().tolist())

    # –±–ª–∏–∂–∞–π—à–∏–µ —É—Ä–æ–≤–Ω–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã
    resistance = [x for x in r_candidates if x > price]
    support = [x for x in s_candidates if x < price]

    # –æ—Å—Ç–∞–≤–∏–º –ø–æ 2
    resistance = resistance[:2] if len(resistance) >= 2 else resistance
    support = support[-2:] if len(support) >= 2 else support  # –±–ª–∏–∂–Ω–∏–µ —Å–Ω–∏–∑—É ‚Äî –±–ª–∏–∂–µ –∫ —Ü–µ–Ω–µ

    # –æ–∫—Ä—É–≥–ª–∏–º –∞–¥–µ–∫–≤–∞—Ç–Ω–æ
    def _round(x: float) -> float:
        if price >= 1000:
            return round(x, 2)
        elif price >= 10:
            return round(x, 2)
        else:
            return round(x, 4)

    resistance = [_round(v) for v in resistance]
    support = [_round(v) for v in support]
    return {"resistance": resistance, "support": support}


def _pick_tp_sl(
    side: str,
    price: float,
    levels: Dict[str, List[float]],
    atr: Optional[float] = None,
    min_rr: float = 2.0,
    prefer_rr: float = 3.0
) -> Tuple[Optional[float], Optional[float], Optional[float]]:
    """
    –í—ã–±–æ—Ä TP1/TP2/SL –æ—Ç —É—Ä–æ–≤–Ω–µ–π:
      - LONG: TP ‚Äî –±–ª–∏–∂–∞–π—à–∏–µ R –≤—ã—à–µ —Ü–µ–Ω—ã; SL ‚Äî –±–ª–∏–∂–∞–π—à–∏–π S –Ω–∏–∂–µ —Ü–µ–Ω—ã
      - SHORT: TP ‚Äî –±–ª–∏–∂–∞–π—à–∏–µ S –Ω–∏–∂–µ —Ü–µ–Ω—ã; SL ‚Äî –±–ª–∏–∂–∞–π—à–∏–π R –≤—ã—à–µ —Ü–µ–Ω—ã
    –ó–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∏—Å–∫/–ø—Ä–∏–±—ã–ª—å. –ï—Å–ª–∏ —É—Ä–æ–≤–µ–Ω—å –¥–∞—ë—Ç RR < min_rr, —Å—á–∏—Ç–∞–µ–º —Å–∏–≥–Ω–∞–ª —Å–ª–∞–±—ã–º (–Ω–æ –≤—Å—ë —Ä–∞–≤–Ω–æ –≤–µ—Ä–Ω—ë–º).
    –ï—Å–ª–∏ —É—Ä–æ–≤–Ω–µ–π –Ω–µ—Ç ‚Äî —Ñ–æ–ª–±—ç–∫ –Ω–∞ ATR.
    """
    res = levels.get("resistance", []) or []
    sup = levels.get("support", []) or []

    tp1 = tp2 = sl = None

    def rr(tp: float, sl_: float) -> float:
        if side == "long":
            risk = max(price - sl_, 1e-9)
            reward = max(tp - price, 1e-9)
        else:
            risk = max(sl_ - price, 1e-9)
            reward = max(price - tp, 1e-9)
        return reward / risk if risk > 0 else 0.0

    if side == "long":
        # SL ‚Äî –±–ª–∏–∂–∞–π—à–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –Ω–∏–∂–µ —Ü–µ–Ω—ã
        sl_candidates = [s for s in sup if s < price]
        if sl_candidates:
            sl = sl_candidates[-1]
        elif atr:
            sl = price - 1.0 * atr  # fallback

        # TP ‚Äî –±–ª–∏–∂–∞–π—à–∏–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
        tp_candidates = [r for r in res if r > price]
        if tp_candidates:
            tp1 = tp_candidates[0]
            tp2 = tp_candidates[1] if len(tp_candidates) > 1 else None

        # –µ—Å–ª–∏ tp2 –Ω–µ—Ç, –Ω–æ –µ—Å—Ç—å atr ‚Äî –º–æ–∂–Ω–æ –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å RR target
        if tp1 and not tp2 and sl is not None:
            # –µ—Å–ª–∏ RR –¥–æ tp1 < min_rr, –ø–æ–¥–±–µ—Ä—ë–º –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π tp2 —Å prefer_rr
            if rr(tp1, sl) < min_rr and prefer_rr and prefer_rr > 0:
                # —Ü–µ–ª–µ–≤–æ–π tp2 –¥–ª—è RR‚âàprefer_rr
                if side == "long":
                    tp2 = price + prefer_rr * (price - sl)
                else:
                    tp2 = price - prefer_rr * (sl - price)

    else:  # short
        # SL ‚Äî –±–ª–∏–∂–∞–π—à–µ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –≤—ã—à–µ —Ü–µ–Ω—ã
        sl_candidates = [r for r in res if r > price]
        if sl_candidates:
            sl = sl_candidates[0]
        elif atr:
            sl = price + 1.0 * atr  # fallback

        # TP ‚Äî –±–ª–∏–∂–∞–π—à–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏
        tp_candidates = [s for s in sup if s < price]
        tp_candidates.sort(reverse=True)  # –±–ª–∏–∂–Ω–∏–µ —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
        if tp_candidates:
            tp1 = tp_candidates[0]
            tp2 = tp_candidates[1] if len(tp_candidates) > 1 else None

        if tp1 and not tp2 and sl is not None:
            if rr(tp1, sl) < min_rr and prefer_rr and prefer_rr > 0:
                if side == "long":
                    tp2 = price + prefer_rr * (price - sl)
                else:
                    tp2 = price - prefer_rr * (sl - price)

    # –ù–µ –¥–æ–ø—É—Å–∫–∞–µ–º —Ä–∞–≤–Ω—ã—Ö TP1/TP2
    if tp1 and tp2 and abs(tp1 - tp2) < 1e-9:
        tp2 = None

    return tp1, tp2, sl


def _fmt_num(x: Optional[float]) -> str:
    if x is None:
        return "-"
    # –∫–æ–º–ø–∞–∫—Ç–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
    if x >= 1000:
        return f"{x:,.2f}".replace(",", " ")
    elif x >= 10:
        return f"{x:,.2f}"
    else:
        return f"{x:.6f}".rstrip("0").rstrip(".")


# ------------- –û–°–ù–û–í–ù–ê–Ø –ê–ù–ê–õ–ò–¢–ò–ö–ê -------------
async def analyze_symbol(symbol: str, tf: str = "1h") -> Dict[str, Any]:
    """
    –°—á–∏—Ç–∞–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã, —É—Ä–æ–≤–Ω–∏ –∏ –≤—ã–¥–∞—ë—Ç —Ç–æ—Ä–≥–æ–≤—É—é –∏–¥–µ—é:
      - direction: long/short/none
      - confidence: 0..100
      - —É—Ä–æ–≤–Ω–∏, TP/SL –æ—Ç —É—Ä–æ–≤–Ω–µ–π
    """
    # —Å–≤–µ—á–∏ 1h
    df_1h, ex_1h = _safe_get_candles(symbol, tf, limit=400)
    # —Ç—Ä–µ–Ω–¥ 4h
    df_4h, _ = _safe_get_candles(symbol, "4h", limit=300)

    price = float(df_1h["close"].iloc[-1])

    # –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã 1h
    ema_fast = _ema(df_1h["close"], EMA_FAST)
    ema_slow = _ema(df_1h["close"], EMA_SLOW)
    rsi = RSIIndicator(df_1h["close"], window=RSI_PERIOD).rsi()
    macd = MACD(df_1h["close"]).macd() - MACD(df_1h["close"]).macd_signal()
    adx = ADXIndicator(df_1h["high"], df_1h["low"], df_1h["close"], window=ADX_PERIOD).adx()
    bbw = _bb_width(df_1h["close"], period=BB_PERIOD)

    ema9 = float(ema_fast.iloc[-1])
    ema21 = float(ema_slow.iloc[-1])
    rsi_v = float(rsi.iloc[-1])
    macd_d = float(macd.iloc[-1])
    adx_v = float(adx.iloc[-1])
    bbw_v = float(bbw.iloc[-1])

    # —Ç—Ä–µ–Ω–¥ 4h (–ø–æ –Ω–∞–∫–ª–æ–Ω—É EMA21)
    ema21_4h = _ema(df_4h["close"], 21)
    ema21_4h_slope = float(ema21_4h.iloc[-1] - ema21_4h.iloc[-5])  # –≥—Ä—É–±–æ
    trend4h = "up" if ema21_4h_slope > 0 else "down"

    # –ø—Ä–∏–º–µ—Ä–Ω—ã–π ATR —á–µ—Ä–µ–∑ BBW (–±–µ–∑ –≤–Ω–µ—à–Ω–µ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏)
    # BB width(%) ~ 4œÉ/MA ‚Üí œÉ ~ (BBW% * MA)/400 ‚Üí ATR ~ ~ 1.5œÉ
    ma = df_1h["close"].rolling(BB_PERIOD).mean().iloc[-1]
    sigma = (bbw_v / 100.0) * ma / 4.0 if ma else 0.0
    atr_approx = 1.5 * sigma if sigma else None

    # —É—Ä–æ–≤–Ω–∏
    levels = _calc_levels(df_1h, lookback=150)

    # –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å
    score_long = 0
    score_short = 0

    if ema9 > ema21:
        score_long += 20
    else:
        score_short += 20

    if rsi_v > 55:
        score_long += 10
    elif rsi_v < 45:
        score_short += 10

    if macd_d > 0:
        score_long += 10
    else:
        score_short += 10

    if adx_v >= 20:
        # —Ç—Ä–µ–Ω–¥–æ–≤–æ—Å—Ç—å –¥–æ–±–∞–≤–ª—è–µ—Ç –≤–µ—Å–∞ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é EMA
        if ema9 > ema21:
            score_long += 10
        else:
            score_short += 10

    # —Ç—Ä–µ–Ω–¥ 4h
    if trend4h == "up":
        score_long += 10
    else:
        score_short += 10

    # –Ω–æ—Ä–º–∏—Ä—É–µ–º
    raw_long = score_long
    raw_short = score_short
    if raw_long > raw_short:
        direction = "long"
        conf = min(95, 50 + (raw_long - raw_short))  # 50..95
    elif raw_short > raw_long:
        direction = "short"
        conf = min(95, 50 + (raw_short - raw_long))
    else:
        direction = "none"
        conf = 50

    # TP/SL –æ—Ç —É—Ä–æ–≤–Ω–µ–π
    tp1, tp2, sl = _pick_tp_sl(
        side=direction,
        price=price,
        levels=levels,
        atr=atr_approx,
        min_rr=2.0,
        prefer_rr=3.0
    )

    # —Å–æ–±–µ—Ä—ë–º –ø—Ä–∏—á–∏–Ω—ã
    reasons = [
        f"4H —Ç—Ä–µ–Ω–¥: {trend4h}",
        f"EMA9/21: {'up' if ema9 > ema21 else 'down'}, RSI={rsi_v:.1f}, MACDŒî={macd_d:.4f}, ADX={adx_v:.1f}",
    ]

    return {
        "symbol": symbol,
        "exchange": ex_1h or "‚Äî",
        "price": price,
        "tf": tf,
        "direction": direction,
        "confidence": int(round(conf)),
        "ind": {
            "ema9": ema9,
            "ema21": ema21,
            "rsi": rsi_v,
            "macd_delta": macd_d,
            "adx": adx_v,
            "bbw": bbw_v,
        },
        "levels": levels,
        "tp1": tp1,
        "tp2": tp2,
        "sl": sl,
        "reasons": reasons,
        "updated": pd.Timestamp.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
    }


def format_signal(sig: Dict[str, Any]) -> str:
    """
    –í—ã–≤–æ–¥ –≤ —Ñ–æ—Ä–º–∞—Ç–µ ¬´üíé –°–ò–ì–ù–ê–õ¬ª —Å TP/SL –æ—Ç —É—Ä–æ–≤–Ω–µ–π.
    """
    symbol = sig["symbol"]
    ex = sig.get("exchange") or "‚Äî"
    price = _fmt_num(sig["price"])
    tf = sig["tf"]
    side = sig["direction"]
    conf = sig["confidence"]

    # —Å—Ç—Ä–æ–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    if side == "long":
        side_str = f"LONG ‚Üë ({conf}%)"
    elif side == "short":
        side_str = f"SHORT ‚Üì ({conf}%)"
    else:
        side_str = f"NONE ({conf}%)"

    # —É—Ä–æ–≤–Ω–∏
    levels = sig.get("levels", {})
    res = levels.get("resistance", []) or []
    sup = levels.get("support", []) or []
    r_str = " ‚Ä¢ ".join(_fmt_num(x) for x in res) if res else "-"
    s_str = " ‚Ä¢ ".join(_fmt_num(x) for x in sup) if sup else "-"

    # tp/sl
    tp1 = _fmt_num(sig.get("tp1"))
    tp2 = _fmt_num(sig.get("tp2"))
    sl = _fmt_num(sig.get("sl"))

    reasons = sig.get("reasons", [])
    reasons_str = "\n".join(f"‚Ä¢ {r}" for r in reasons)

    updated = sig.get("updated", "")

    return (
        "üíé –°–ò–ì–ù–ê–õ\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üîπ –ü–∞—Ä–∞: {symbol}\n"
        f"üìä –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {side_str}\n"
        f"üíµ –¶–µ–Ω–∞: {price}\n"
        f"üïí –¢–§: {tf}\n"
        f"üè¶ –ë–∏—Ä–∂–∞: {ex}\n"
        f"üóì –û–±–Ω–æ–≤–ª–µ–Ω–æ: {updated}\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üìå –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ:\n"
        f"{reasons_str}\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üìè –£—Ä–æ–≤–Ω–∏:\n"
        f"R: {r_str}\n"
        f"S: {s_str}\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üéØ –¶–µ–ª–∏:\n"
        f"TP1: {tp1}\n"
        f"TP2: {tp2}\n"
        f"üõ° SL: {sl}\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    )